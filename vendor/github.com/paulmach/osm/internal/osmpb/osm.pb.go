// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osm.proto

package osmpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Relation_MemberType int32

const (
	Relation_NODE     Relation_MemberType = 0
	Relation_WAY      Relation_MemberType = 1
	Relation_RELATION Relation_MemberType = 2
)

var Relation_MemberType_name = map[int32]string{
	0: "NODE",
	1: "WAY",
	2: "RELATION",
}

var Relation_MemberType_value = map[string]int32{
	"NODE":     0,
	"WAY":      1,
	"RELATION": 2,
}

func (x Relation_MemberType) Enum() *Relation_MemberType {
	p := new(Relation_MemberType)
	*p = x
	return p
}

func (x Relation_MemberType) String() string {
	return proto.EnumName(Relation_MemberType_name, int32(x))
}

func (x *Relation_MemberType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Relation_MemberType_value, data, "Relation_MemberType")
	if err != nil {
		return err
	}
	*x = Relation_MemberType(value)
	return nil
}

func (Relation_MemberType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{10, 0}
}

type Changeset struct {
	Id *int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Parallel arrays.
	Keys      []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals      []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	UserId    *int32   `protobuf:"varint,5,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	UserSid   *uint32  `protobuf:"varint,6,opt,name=user_sid,json=userSid" json:"user_sid,omitempty"`
	CreatedAt *int64   `protobuf:"varint,7,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	ClosedAt  *int64   `protobuf:"varint,8,opt,name=closed_at,json=closedAt" json:"closed_at,omitempty"`
	Open      *bool    `protobuf:"varint,9,opt,name=open" json:"open,omitempty"`
	Bounds    *Bounds  `protobuf:"bytes,10,opt,name=bounds" json:"bounds,omitempty"`
	Change    *Change  `protobuf:"bytes,11,opt,name=change" json:"change,omitempty"`
	// contains the tag strings for everything
	// in this entire changeset.
	Strings []string `protobuf:"bytes,20,rep,name=strings" json:"strings,omitempty"`
}

func (m *Changeset) Reset()         { *m = Changeset{} }
func (m *Changeset) String() string { return proto.CompactTextString(m) }
func (*Changeset) ProtoMessage()    {}
func (*Changeset) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{0}
}
func (m *Changeset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Changeset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Changeset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Changeset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Changeset.Merge(m, src)
}
func (m *Changeset) XXX_Size() int {
	return m.Size()
}
func (m *Changeset) XXX_DiscardUnknown() {
	xxx_messageInfo_Changeset.DiscardUnknown(m)
}

var xxx_messageInfo_Changeset proto.InternalMessageInfo

func (m *Changeset) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *Changeset) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Changeset) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Changeset) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *Changeset) GetUserSid() uint32 {
	if m != nil && m.UserSid != nil {
		return *m.UserSid
	}
	return 0
}

func (m *Changeset) GetCreatedAt() int64 {
	if m != nil && m.CreatedAt != nil {
		return *m.CreatedAt
	}
	return 0
}

func (m *Changeset) GetClosedAt() int64 {
	if m != nil && m.ClosedAt != nil {
		return *m.ClosedAt
	}
	return 0
}

func (m *Changeset) GetOpen() bool {
	if m != nil && m.Open != nil {
		return *m.Open
	}
	return false
}

func (m *Changeset) GetBounds() *Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *Changeset) GetChange() *Change {
	if m != nil {
		return m.Change
	}
	return nil
}

func (m *Changeset) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Bounds struct {
	MinLon int64 `protobuf:"zigzag64,1,req,name=min_lon,json=minLon" json:"min_lon"`
	MaxLon int64 `protobuf:"zigzag64,2,req,name=max_lon,json=maxLon" json:"max_lon"`
	MinLat int64 `protobuf:"zigzag64,3,req,name=min_lat,json=minLat" json:"min_lat"`
	MaxLat int64 `protobuf:"zigzag64,4,req,name=max_lat,json=maxLat" json:"max_lat"`
}

func (m *Bounds) Reset()         { *m = Bounds{} }
func (m *Bounds) String() string { return proto.CompactTextString(m) }
func (*Bounds) ProtoMessage()    {}
func (*Bounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{1}
}
func (m *Bounds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bounds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bounds.Merge(m, src)
}
func (m *Bounds) XXX_Size() int {
	return m.Size()
}
func (m *Bounds) XXX_DiscardUnknown() {
	xxx_messageInfo_Bounds.DiscardUnknown(m)
}

var xxx_messageInfo_Bounds proto.InternalMessageInfo

func (m *Bounds) GetMinLon() int64 {
	if m != nil {
		return m.MinLon
	}
	return 0
}

func (m *Bounds) GetMaxLon() int64 {
	if m != nil {
		return m.MaxLon
	}
	return 0
}

func (m *Bounds) GetMinLat() int64 {
	if m != nil {
		return m.MinLat
	}
	return 0
}

func (m *Bounds) GetMaxLat() int64 {
	if m != nil {
		return m.MaxLat
	}
	return 0
}

type Change struct {
	Create *OSM `protobuf:"bytes,1,opt,name=create" json:"create,omitempty"`
	Modify *OSM `protobuf:"bytes,2,opt,name=modify" json:"modify,omitempty"`
	Delete *OSM `protobuf:"bytes,3,opt,name=delete" json:"delete,omitempty"`
	// elements that give the change extra context like
	// nodes of the ways, and previous versions.
	Context *OSM `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
	// contains the tag strings if this is the root of the data.
	Strings []string `protobuf:"bytes,20,rep,name=strings" json:"strings,omitempty"`
}

func (m *Change) Reset()         { *m = Change{} }
func (m *Change) String() string { return proto.CompactTextString(m) }
func (*Change) ProtoMessage()    {}
func (*Change) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{2}
}
func (m *Change) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Change) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Change.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Change) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Change.Merge(m, src)
}
func (m *Change) XXX_Size() int {
	return m.Size()
}
func (m *Change) XXX_DiscardUnknown() {
	xxx_messageInfo_Change.DiscardUnknown(m)
}

var xxx_messageInfo_Change proto.InternalMessageInfo

func (m *Change) GetCreate() *OSM {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *Change) GetModify() *OSM {
	if m != nil {
		return m.Modify
	}
	return nil
}

func (m *Change) GetDelete() *OSM {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *Change) GetContext() *OSM {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Change) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Tags struct {
	// encoded as [key1, val1, key2, val2, etc.]
	KeysVals []string `protobuf:"bytes,1,rep,name=keys_vals,json=keysVals" json:"keys_vals,omitempty"`
}

func (m *Tags) Reset()         { *m = Tags{} }
func (m *Tags) String() string { return proto.CompactTextString(m) }
func (*Tags) ProtoMessage()    {}
func (*Tags) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{3}
}
func (m *Tags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tags.Merge(m, src)
}
func (m *Tags) XXX_Size() int {
	return m.Size()
}
func (m *Tags) XXX_DiscardUnknown() {
	xxx_messageInfo_Tags.DiscardUnknown(m)
}

var xxx_messageInfo_Tags proto.InternalMessageInfo

func (m *Tags) GetKeysVals() []string {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

type OSM struct {
	Bounds *Bounds `protobuf:"bytes,1,opt,name=bounds" json:"bounds,omitempty"`
	// an encoded should have either nodes or a dense_nodes, but not both.
	Nodes      []*Node     `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty"`
	DenseNodes *DenseNodes `protobuf:"bytes,3,opt,name=dense_nodes,json=denseNodes" json:"dense_nodes,omitempty"`
	Ways       []*Way      `protobuf:"bytes,4,rep,name=ways" json:"ways,omitempty"`
	Relations  []*Relation `protobuf:"bytes,5,rep,name=relations" json:"relations,omitempty"`
	// contains the tag strings if this is the root of the data.
	Strings []string `protobuf:"bytes,15,rep,name=strings" json:"strings,omitempty"`
}

func (m *OSM) Reset()         { *m = OSM{} }
func (m *OSM) String() string { return proto.CompactTextString(m) }
func (*OSM) ProtoMessage()    {}
func (*OSM) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{4}
}
func (m *OSM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OSM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OSM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OSM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OSM.Merge(m, src)
}
func (m *OSM) XXX_Size() int {
	return m.Size()
}
func (m *OSM) XXX_DiscardUnknown() {
	xxx_messageInfo_OSM.DiscardUnknown(m)
}

var xxx_messageInfo_OSM proto.InternalMessageInfo

func (m *OSM) GetBounds() *Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *OSM) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *OSM) GetDenseNodes() *DenseNodes {
	if m != nil {
		return m.DenseNodes
	}
	return nil
}

func (m *OSM) GetWays() []*Way {
	if m != nil {
		return m.Ways
	}
	return nil
}

func (m *OSM) GetRelations() []*Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func (m *OSM) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type Node struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	Lat  int64    `protobuf:"zigzag64,8,req,name=lat" json:"lat"`
	Lon  int64    `protobuf:"zigzag64,9,req,name=lon" json:"lon"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{5}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Node) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Node) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Node) GetLat() int64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *Node) GetLon() int64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

type Info struct {
	Version   int32 `protobuf:"varint,1,opt,name=version" json:"version"`
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp"`
	// these can be omitted if the object represents one changeset
	// since they will be all the same. However tests on 200k changesets
	// show this saves about 17 bytes per changeset on average after gzip.
	ChangesetId int64  `protobuf:"varint,3,opt,name=changeset_id,json=changesetId" json:"changeset_id"`
	UserId      int32  `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id"`
	UserSid     uint32 `protobuf:"varint,5,opt,name=user_sid,json=userSid" json:"user_sid"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API. This info may be omitted if it can be inferred from its group
	// ie. create, modify, delete.
	Visible *bool `protobuf:"varint,6,opt,name=visible" json:"visible,omitempty"`
	// the time this element was committed into the db. Could be much later than
	// timestamp for large uploads.
	Committed *int64 `protobuf:"varint,7,opt,name=committed" json:"committed,omitempty"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{6}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(m, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

func (m *Info) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Info) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Info) GetChangesetId() int64 {
	if m != nil {
		return m.ChangesetId
	}
	return 0
}

func (m *Info) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Info) GetUserSid() uint32 {
	if m != nil {
		return m.UserSid
	}
	return 0
}

func (m *Info) GetVisible() bool {
	if m != nil && m.Visible != nil {
		return *m.Visible
	}
	return false
}

func (m *Info) GetCommitted() int64 {
	if m != nil && m.Committed != nil {
		return *m.Committed
	}
	return 0
}

type DenseNodes struct {
	Ids       []int64    `protobuf:"zigzag64,1,rep,packed,name=ids" json:"ids,omitempty"`
	DenseInfo *DenseInfo `protobuf:"bytes,5,opt,name=dense_info,json=denseInfo" json:"dense_info,omitempty"`
	Lats      []int64    `protobuf:"zigzag64,8,rep,packed,name=lats" json:"lats,omitempty"`
	Lons      []int64    `protobuf:"zigzag64,9,rep,packed,name=lons" json:"lons,omitempty"`
	// Special packing of keys and vals into one array. We use a single stringid
	// of 0 to delimit when the tags of a node ends and the tags of the next node
	// begin. The storage pattern is: ((<keyid> <valid>)* '0' )* As an exception,
	// if no node in the current block has any key/value pairs, this array does
	// not contain any delimiters, but is simply empty.
	KeysVals []uint32 `protobuf:"varint,10,rep,packed,name=keys_vals,json=keysVals" json:"keys_vals,omitempty"`
	Strings  []string `protobuf:"bytes,15,rep,name=strings" json:"strings,omitempty"`
}

func (m *DenseNodes) Reset()         { *m = DenseNodes{} }
func (m *DenseNodes) String() string { return proto.CompactTextString(m) }
func (*DenseNodes) ProtoMessage()    {}
func (*DenseNodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{7}
}
func (m *DenseNodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenseNodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenseNodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenseNodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenseNodes.Merge(m, src)
}
func (m *DenseNodes) XXX_Size() int {
	return m.Size()
}
func (m *DenseNodes) XXX_DiscardUnknown() {
	xxx_messageInfo_DenseNodes.DiscardUnknown(m)
}

var xxx_messageInfo_DenseNodes proto.InternalMessageInfo

func (m *DenseNodes) GetIds() []int64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *DenseNodes) GetDenseInfo() *DenseInfo {
	if m != nil {
		return m.DenseInfo
	}
	return nil
}

func (m *DenseNodes) GetLats() []int64 {
	if m != nil {
		return m.Lats
	}
	return nil
}

func (m *DenseNodes) GetLons() []int64 {
	if m != nil {
		return m.Lons
	}
	return nil
}

func (m *DenseNodes) GetKeysVals() []uint32 {
	if m != nil {
		return m.KeysVals
	}
	return nil
}

func (m *DenseNodes) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type DenseInfo struct {
	Versions   []int32 `protobuf:"varint,1,rep,packed,name=versions" json:"versions,omitempty"`
	Timestamps []int64 `protobuf:"zigzag64,2,rep,packed,name=timestamps" json:"timestamps,omitempty"`
	// these will be omitted if the object represents one changeset
	// and these will be all the same.
	ChangesetIds []int64 `protobuf:"zigzag64,3,rep,packed,name=changeset_ids,json=changesetIds" json:"changeset_ids,omitempty"`
	UserIds      []int32 `protobuf:"zigzag32,4,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	UserSids     []int32 `protobuf:"zigzag32,5,rep,packed,name=user_sids,json=userSids" json:"user_sids,omitempty"`
	// The visible flag is used to store history information. It indicates that
	// the current object version has been created by a delete operation on the
	// OSM API. This info may be omitted if it can be inferred from its group
	// ie. create, modify, delete.
	Visibles []bool `protobuf:"varint,6,rep,packed,name=visibles" json:"visibles,omitempty"`
	// the time this element was committed into the db. Could be much later than
	// timestamp for large uploads.
	Committeds []int64 `protobuf:"zigzag64,7,rep,packed,name=committeds" json:"committeds,omitempty"`
}

func (m *DenseInfo) Reset()         { *m = DenseInfo{} }
func (m *DenseInfo) String() string { return proto.CompactTextString(m) }
func (*DenseInfo) ProtoMessage()    {}
func (*DenseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{8}
}
func (m *DenseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenseInfo.Merge(m, src)
}
func (m *DenseInfo) XXX_Size() int {
	return m.Size()
}
func (m *DenseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DenseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DenseInfo proto.InternalMessageInfo

func (m *DenseInfo) GetVersions() []int32 {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *DenseInfo) GetTimestamps() []int64 {
	if m != nil {
		return m.Timestamps
	}
	return nil
}

func (m *DenseInfo) GetChangesetIds() []int64 {
	if m != nil {
		return m.ChangesetIds
	}
	return nil
}

func (m *DenseInfo) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *DenseInfo) GetUserSids() []int32 {
	if m != nil {
		return m.UserSids
	}
	return nil
}

func (m *DenseInfo) GetVisibles() []bool {
	if m != nil {
		return m.Visibles
	}
	return nil
}

func (m *DenseInfo) GetCommitteds() []int64 {
	if m != nil {
		return m.Committeds
	}
	return nil
}

type Way struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	// Only one of the next two must be included.
	// refs are DELTA coded node ids. If there is more info,
	// versions, changeset ids, lat and lon will be encoded
	// as a DenseMembers object.
	Refs         []int64       `protobuf:"zigzag64,8,rep,packed,name=refs" json:"refs,omitempty"`
	DenseMembers *DenseMembers `protobuf:"bytes,9,opt,name=dense_members,json=denseMembers" json:"dense_members,omitempty"`
	// updates are changes to members that did not happen
	// at a similar time to a change in the parent.
	Updates *DenseMembers `protobuf:"bytes,10,opt,name=updates" json:"updates,omitempty"`
}

func (m *Way) Reset()         { *m = Way{} }
func (m *Way) String() string { return proto.CompactTextString(m) }
func (*Way) ProtoMessage()    {}
func (*Way) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{9}
}
func (m *Way) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Way) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Way.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Way) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Way.Merge(m, src)
}
func (m *Way) XXX_Size() int {
	return m.Size()
}
func (m *Way) XXX_DiscardUnknown() {
	xxx_messageInfo_Way.DiscardUnknown(m)
}

var xxx_messageInfo_Way proto.InternalMessageInfo

func (m *Way) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Way) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Way) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Way) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Way) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *Way) GetDenseMembers() *DenseMembers {
	if m != nil {
		return m.DenseMembers
	}
	return nil
}

func (m *Way) GetUpdates() *DenseMembers {
	if m != nil {
		return m.Updates
	}
	return nil
}

type Relation struct {
	Id int64 `protobuf:"varint,1,req,name=id" json:"id"`
	// Parallel arrays.
	Keys []uint32 `protobuf:"varint,2,rep,packed,name=keys" json:"keys,omitempty"`
	Vals []uint32 `protobuf:"varint,3,rep,packed,name=vals" json:"vals,omitempty"`
	Info *Info    `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
	// Parallel arrays
	// Roles has been changed int32 -> uint32 form the osm proto,
	// this is for consistency and backwards compatible.
	Roles []uint32              `protobuf:"varint,8,rep,packed,name=roles" json:"roles,omitempty"`
	Refs  []int64               `protobuf:"zigzag64,9,rep,packed,name=refs" json:"refs,omitempty"`
	Types []Relation_MemberType `protobuf:"varint,10,rep,packed,name=types,enum=osm.Relation_MemberType" json:"types,omitempty"`
	// DenseMembers includes annotated information about the members
	DenseMembers *DenseMembers `protobuf:"bytes,11,opt,name=dense_members,json=denseMembers" json:"dense_members,omitempty"`
	// updates are changes to members that did not happen
	// at a similar time to a change in the parent.
	Updates *DenseMembers `protobuf:"bytes,12,opt,name=updates" json:"updates,omitempty"`
}

func (m *Relation) Reset()         { *m = Relation{} }
func (m *Relation) String() string { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()    {}
func (*Relation) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{10}
}
func (m *Relation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relation.Merge(m, src)
}
func (m *Relation) XXX_Size() int {
	return m.Size()
}
func (m *Relation) XXX_DiscardUnknown() {
	xxx_messageInfo_Relation.DiscardUnknown(m)
}

var xxx_messageInfo_Relation proto.InternalMessageInfo

func (m *Relation) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Relation) GetKeys() []uint32 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Relation) GetVals() []uint32 {
	if m != nil {
		return m.Vals
	}
	return nil
}

func (m *Relation) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Relation) GetRoles() []uint32 {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *Relation) GetRefs() []int64 {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *Relation) GetTypes() []Relation_MemberType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Relation) GetDenseMembers() *DenseMembers {
	if m != nil {
		return m.DenseMembers
	}
	return nil
}

func (m *Relation) GetUpdates() *DenseMembers {
	if m != nil {
		return m.Updates
	}
	return nil
}

type DenseMembers struct {
	Indexes      []int32 `protobuf:"zigzag32,1,rep,packed,name=indexes" json:"indexes,omitempty"`
	Versions     []int32 `protobuf:"varint,2,rep,packed,name=versions" json:"versions,omitempty"`
	Timestamps   []int64 `protobuf:"zigzag64,3,rep,packed,name=timestamps" json:"timestamps,omitempty"`
	ChangesetIds []int64 `protobuf:"zigzag64,4,rep,packed,name=changeset_ids,json=changesetIds" json:"changeset_ids,omitempty"`
	Orientation  []int32 `protobuf:"zigzag32,5,rep,packed,name=orientation" json:"orientation,omitempty"`
	// included if some of the members are nodes
	Lats []int64 `protobuf:"zigzag64,8,rep,packed,name=lats" json:"lats,omitempty"`
	Lons []int64 `protobuf:"zigzag64,9,rep,packed,name=lons" json:"lons,omitempty"`
}

func (m *DenseMembers) Reset()         { *m = DenseMembers{} }
func (m *DenseMembers) String() string { return proto.CompactTextString(m) }
func (*DenseMembers) ProtoMessage()    {}
func (*DenseMembers) Descriptor() ([]byte, []int) {
	return fileDescriptor_537306c3a4d945df, []int{11}
}
func (m *DenseMembers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DenseMembers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DenseMembers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DenseMembers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DenseMembers.Merge(m, src)
}
func (m *DenseMembers) XXX_Size() int {
	return m.Size()
}
func (m *DenseMembers) XXX_DiscardUnknown() {
	xxx_messageInfo_DenseMembers.DiscardUnknown(m)
}

var xxx_messageInfo_DenseMembers proto.InternalMessageInfo

func (m *DenseMembers) GetIndexes() []int32 {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *DenseMembers) GetVersions() []int32 {
	if m != nil {
		return m.Versions
	}
	return nil
}

func (m *DenseMembers) GetTimestamps() []int64 {
	if m != nil {
		return m.Timestamps
	}
	return nil
}

func (m *DenseMembers) GetChangesetIds() []int64 {
	if m != nil {
		return m.ChangesetIds
	}
	return nil
}

func (m *DenseMembers) GetOrientation() []int32 {
	if m != nil {
		return m.Orientation
	}
	return nil
}

func (m *DenseMembers) GetLats() []int64 {
	if m != nil {
		return m.Lats
	}
	return nil
}

func (m *DenseMembers) GetLons() []int64 {
	if m != nil {
		return m.Lons
	}
	return nil
}

func init() {
	proto.RegisterEnum("osm.Relation_MemberType", Relation_MemberType_name, Relation_MemberType_value)
	proto.RegisterType((*Changeset)(nil), "osm.Changeset")
	proto.RegisterType((*Bounds)(nil), "osm.Bounds")
	proto.RegisterType((*Change)(nil), "osm.Change")
	proto.RegisterType((*Tags)(nil), "osm.Tags")
	proto.RegisterType((*OSM)(nil), "osm.OSM")
	proto.RegisterType((*Node)(nil), "osm.Node")
	proto.RegisterType((*Info)(nil), "osm.Info")
	proto.RegisterType((*DenseNodes)(nil), "osm.DenseNodes")
	proto.RegisterType((*DenseInfo)(nil), "osm.DenseInfo")
	proto.RegisterType((*Way)(nil), "osm.Way")
	proto.RegisterType((*Relation)(nil), "osm.Relation")
	proto.RegisterType((*DenseMembers)(nil), "osm.DenseMembers")
}

func init() { proto.RegisterFile("osm.proto", fileDescriptor_537306c3a4d945df) }

var fileDescriptor_537306c3a4d945df = []byte{
	// 1060 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xbf, 0x6e, 0x1b, 0xc7,
	0x13, 0xe6, 0xde, 0x1d, 0xc9, 0xbb, 0x21, 0x65, 0xcb, 0x0b, 0xc1, 0x58, 0xfc, 0x7e, 0x0e, 0xc5,
	0x9c, 0x02, 0x98, 0x80, 0x21, 0x39, 0x60, 0x91, 0x5e, 0x8a, 0x5d, 0x08, 0xb0, 0x24, 0xe0, 0x24,
	0x44, 0x48, 0x1a, 0xe2, 0xc8, 0x5d, 0xd1, 0x87, 0xf0, 0x6e, 0x09, 0xee, 0xd2, 0x11, 0xfb, 0x3c,
	0x40, 0xfa, 0xbc, 0x42, 0x1e, 0x21, 0x0f, 0xe0, 0xd2, 0x5d, 0x52, 0x05, 0x81, 0x54, 0x04, 0xa9,
	0x52, 0xa6, 0x49, 0x11, 0xec, 0xec, 0xfd, 0x23, 0xe3, 0x3f, 0x71, 0x0a, 0x77, 0xdc, 0x6f, 0xbe,
	0xd9, 0x9b, 0xfd, 0xe6, 0x9b, 0x21, 0x04, 0x52, 0xa5, 0x07, 0xf3, 0x85, 0xd4, 0x92, 0xba, 0x52,
	0xa5, 0xff, 0xdb, 0x9f, 0x26, 0xfa, 0xf9, 0x72, 0x7c, 0x30, 0x91, 0xe9, 0xe3, 0xa9, 0x9c, 0xca,
	0xc7, 0x18, 0x1b, 0x2f, 0xaf, 0xf0, 0x84, 0x07, 0xfc, 0x65, 0x73, 0xc2, 0x9f, 0x1c, 0x08, 0x3e,
	0x7f, 0x1e, 0x67, 0x53, 0xa1, 0x84, 0xa6, 0x3b, 0xe0, 0x24, 0x9c, 0x91, 0x3e, 0x19, 0xb8, 0x47,
	0xde, 0xcb, 0x5f, 0x76, 0x49, 0xe4, 0x24, 0x9c, 0xde, 0x07, 0xef, 0x6b, 0xb1, 0x52, 0xcc, 0xe9,
	0xbb, 0x83, 0xad, 0x23, 0x67, 0x9b, 0x44, 0x78, 0x36, 0xf8, 0x8b, 0x78, 0xa6, 0x98, 0x5b, 0xe1,
	0xe6, 0x4c, 0x3f, 0x82, 0xf6, 0x52, 0x89, 0xc5, 0x28, 0xe1, 0xac, 0xd9, 0x27, 0x83, 0x66, 0x7e,
	0x55, 0xcb, 0x80, 0xc7, 0x9c, 0xee, 0x82, 0x8f, 0x61, 0x95, 0x70, 0xd6, 0xea, 0x93, 0xc1, 0x56,
	0x1e, 0xc7, 0xa4, 0xf3, 0x84, 0xd3, 0x3d, 0x80, 0xc9, 0x42, 0xc4, 0x5a, 0xf0, 0x51, 0xac, 0x59,
	0xbb, 0x56, 0x4d, 0x90, 0xe3, 0x87, 0x9a, 0x7e, 0x0c, 0xc1, 0x64, 0x26, 0x95, 0xe5, 0xf8, 0x35,
	0x8e, 0x6f, 0xe1, 0x43, 0x4d, 0x19, 0x78, 0x72, 0x2e, 0x32, 0x16, 0xf4, 0xc9, 0xc0, 0xcf, 0xa3,
	0x88, 0xd0, 0x3d, 0x68, 0x8d, 0xe5, 0x32, 0xe3, 0x8a, 0x41, 0x9f, 0x0c, 0x3a, 0xc3, 0xce, 0x81,
	0x51, 0xf1, 0x08, 0xa1, 0x28, 0x0f, 0x19, 0xd2, 0x04, 0x95, 0x61, 0x9d, 0x1a, 0xc9, 0x8a, 0x15,
	0xe5, 0x21, 0xca, 0xa0, 0xad, 0xf4, 0x22, 0xc9, 0xa6, 0x8a, 0xed, 0xf4, 0xdd, 0x41, 0x10, 0x15,
	0xc7, 0xf0, 0x5b, 0x02, 0x2d, 0x7b, 0xa3, 0x11, 0x24, 0x4d, 0xb2, 0xd1, 0x4c, 0x66, 0x8c, 0xf4,
	0x9d, 0x01, 0xc5, 0x5a, 0x1a, 0x51, 0x2b, 0x4d, 0xb2, 0x67, 0x32, 0xc3, 0x70, 0x7c, 0x8d, 0x61,
	0x67, 0x2d, 0x1c, 0x5f, 0x17, 0x61, 0x93, 0x1d, 0x6b, 0xe6, 0x6e, 0x66, 0xc7, 0xba, 0xcc, 0x8e,
	0x35, 0xf3, 0x36, 0xb3, 0x63, 0x1d, 0xfe, 0x40, 0xa0, 0x65, 0x6b, 0xa6, 0x7d, 0x68, 0x59, 0xfd,
	0xb0, 0xc3, 0x9d, 0xa1, 0x8f, 0x0f, 0x3a, 0x3b, 0x3f, 0x89, 0x72, 0xdc, 0x30, 0x52, 0xc9, 0x93,
	0xab, 0x15, 0x73, 0x36, 0x19, 0x16, 0x37, 0x0c, 0x2e, 0x66, 0x42, 0x0b, 0xe6, 0x6e, 0x32, 0x2c,
	0x4e, 0x43, 0x68, 0x4f, 0x64, 0xa6, 0xc5, 0xb5, 0xa9, 0x67, 0x9d, 0x52, 0x04, 0xde, 0xa2, 0xda,
	0x1e, 0x78, 0x17, 0xf1, 0x54, 0xd1, 0xff, 0x43, 0x60, 0x3c, 0x36, 0x42, 0x83, 0x11, 0xe4, 0xf8,
	0x06, 0xf8, 0x22, 0x9e, 0xa9, 0xf0, 0x86, 0x80, 0x7b, 0x76, 0x7e, 0x52, 0x6b, 0x23, 0x79, 0x73,
	0x1b, 0x77, 0xa1, 0x99, 0x49, 0x2e, 0xac, 0x7d, 0x3b, 0xc3, 0x00, 0x39, 0xa7, 0x92, 0x8b, 0xc8,
	0xe2, 0xf4, 0x53, 0xe8, 0x70, 0x91, 0x29, 0x31, 0xb2, 0x34, 0xfb, 0xae, 0xbb, 0x48, 0x7b, 0x62,
	0x70, 0xc3, 0x55, 0x11, 0xf0, 0xf2, 0x37, 0x7d, 0x00, 0xde, 0x37, 0xf1, 0x4a, 0x31, 0x0f, 0x6f,
	0xb4, 0xef, 0xbb, 0x8c, 0x57, 0x11, 0xa2, 0xf4, 0x11, 0x04, 0x0b, 0x31, 0x8b, 0x75, 0x22, 0x33,
	0xc5, 0x9a, 0x48, 0xd9, 0x42, 0x4a, 0x94, 0xa3, 0x51, 0x15, 0xaf, 0x2b, 0x71, 0x77, 0x5d, 0x89,
	0xef, 0x09, 0x78, 0xe6, 0x73, 0xe5, 0x50, 0x3a, 0xb9, 0xc5, 0x1b, 0xff, 0x71, 0x28, 0xbd, 0x24,
	0xbb, 0x92, 0x79, 0x4f, 0xac, 0x0a, 0xc7, 0xd9, 0x95, 0x8c, 0x10, 0xa6, 0xf7, 0xc1, 0x9d, 0xe1,
	0x20, 0x55, 0x0e, 0x32, 0x00, 0xe2, 0xd2, 0x8c, 0x50, 0x1d, 0x97, 0x59, 0xf8, 0x27, 0x01, 0xcf,
	0xa4, 0xd3, 0x1e, 0xb4, 0x5f, 0x88, 0x85, 0x4a, 0xd0, 0xdb, 0xc5, 0xb0, 0x37, 0xa2, 0x02, 0xa4,
	0x21, 0x04, 0x3a, 0x49, 0x85, 0xd2, 0x71, 0x3a, 0x47, 0x57, 0x15, 0x8f, 0xa8, 0x60, 0xfa, 0x10,
	0xba, 0x93, 0x62, 0x07, 0x99, 0xad, 0xe1, 0xd6, 0x68, 0x9d, 0x32, 0x72, 0xcc, 0xeb, 0x9b, 0xc5,
	0xab, 0x7d, 0xec, 0x75, 0x9b, 0xa5, 0x59, 0x6e, 0x96, 0x46, 0xb5, 0x59, 0x4c, 0xb1, 0x89, 0x4a,
	0xc6, 0x33, 0x81, 0x9b, 0xa7, 0x58, 0x0a, 0x05, 0x68, 0x8a, 0x9d, 0xc8, 0x34, 0x4d, 0xb4, 0x16,
	0x7c, 0x63, 0xf1, 0x14, 0x70, 0xf8, 0x23, 0x01, 0xa8, 0x7c, 0x41, 0x77, 0xc0, 0x4d, 0xb8, 0xb5,
	0x28, 0x45, 0xb9, 0xcd, 0x91, 0xee, 0x83, 0xf5, 0xcb, 0x08, 0x35, 0x6f, 0xa2, 0xe6, 0x77, 0x2a,
	0x4b, 0xa1, 0xf0, 0x01, 0x2f, 0x7e, 0x9a, 0xa6, 0xcd, 0x62, 0xad, 0x98, 0x5f, 0xde, 0x82, 0x67,
	0xc4, 0x8d, 0x8b, 0x82, 0x1a, 0x6e, 0x5c, 0xb3, 0x5b, 0x9f, 0x0e, 0x28, 0x3b, 0x5d, 0x4e, 0xc8,
	0x5b, 0x6c, 0xf5, 0x17, 0x81, 0xa0, 0xac, 0x81, 0xf6, 0xc0, 0xcf, 0x1b, 0x65, 0x9f, 0xd0, 0xb4,
	0xf7, 0x14, 0x18, 0x0d, 0x01, 0xca, 0x36, 0x59, 0xaf, 0xd9, 0x32, 0x6a, 0x28, 0x7d, 0x08, 0x5b,
	0xf5, 0xee, 0x59, 0xeb, 0x59, 0x5a, 0xb7, 0xd6, 0x3c, 0x63, 0x41, 0x3f, 0xef, 0x9e, 0x1d, 0x9d,
	0x7b, 0xc8, 0x69, 0xdb, 0xe6, 0xe1, 0xa3, 0x8a, 0xee, 0xd9, 0xb9, 0xb1, 0x71, 0x3f, 0x6f, 0x9e,
	0xc2, 0x62, 0x6d, 0xa3, 0x14, 0x6b, 0xf5, 0xdd, 0x81, 0x9f, 0x17, 0x9b, 0x63, 0xa6, 0xd8, 0xb2,
	0x4d, 0x8a, 0xb5, 0xab, 0x62, 0x2b, 0x34, 0xfc, 0x8d, 0x80, 0x7b, 0x19, 0xaf, 0x3e, 0xd4, 0x50,
	0x79, 0x0b, 0x71, 0xb5, 0xd6, 0x56, 0x73, 0xa6, 0x9f, 0xc1, 0x96, 0x75, 0x47, 0x2a, 0xd2, 0xb1,
	0x58, 0x28, 0xfc, 0x87, 0xea, 0x0c, 0xef, 0x55, 0x06, 0x39, 0xb1, 0x81, 0xa8, 0xcb, 0x6b, 0x27,
	0xfa, 0x08, 0xda, 0xcb, 0x39, 0x8f, 0xb5, 0x28, 0xfe, 0xb7, 0x5e, 0x93, 0x51, 0x30, 0xc2, 0xdf,
	0x1d, 0xf0, 0x8b, 0x8d, 0xf3, 0x61, 0x9e, 0xcb, 0xa0, 0xb9, 0x90, 0xa6, 0x39, 0x7e, 0x99, 0x67,
	0x81, 0x52, 0x88, 0x60, 0x43, 0x88, 0x21, 0x34, 0xf5, 0x6a, 0x2e, 0xac, 0x87, 0xef, 0x0c, 0xd9,
	0xda, 0x9a, 0x3c, 0xb0, 0x4f, 0xba, 0x58, 0xcd, 0x85, 0xbd, 0x0b, 0xa9, 0xff, 0x14, 0xaf, 0xf3,
	0xde, 0xe2, 0x75, 0xdf, 0x29, 0xde, 0x3e, 0x40, 0xf5, 0x75, 0xea, 0x83, 0x77, 0x7a, 0xf6, 0xe4,
	0xe9, 0x76, 0x83, 0xb6, 0xc1, 0xbd, 0x3c, 0xfc, 0x72, 0x9b, 0xd0, 0x2e, 0xf8, 0xd1, 0xd3, 0x67,
	0x87, 0x17, 0xc7, 0x67, 0xa7, 0xdb, 0x4e, 0xf8, 0x07, 0x81, 0x6e, 0xfd, 0x22, 0xfa, 0x00, 0xda,
	0x49, 0xc6, 0xc5, 0xb5, 0xb0, 0x63, 0x95, 0x3b, 0x3d, 0x87, 0xd6, 0xa6, 0xce, 0x79, 0xe7, 0xd4,
	0xb9, 0xff, 0x6e, 0xea, 0xbc, 0x37, 0x4c, 0xdd, 0x27, 0xd0, 0x91, 0x8b, 0x44, 0x64, 0x1a, 0x45,
	0xad, 0x0d, 0x56, 0x1d, 0x7e, 0xdf, 0x0d, 0x74, 0xb4, 0xfb, 0xf2, 0xa6, 0x47, 0x5e, 0xdd, 0xf4,
	0xc8, 0xaf, 0x37, 0x3d, 0xf2, 0xdd, 0x6d, 0xaf, 0xf1, 0xea, 0xb6, 0xd7, 0xf8, 0xf9, 0xb6, 0xd7,
	0xf8, 0xaa, 0x29, 0x55, 0x3a, 0x1f, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xbe, 0x9c, 0xb9, 0x8b,
	0x98, 0x0a, 0x00, 0x00,
}

func (m *Changeset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Changeset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Changeset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strings[iNdEx])
			copy(dAtA[i:], m.Strings[iNdEx])
			i = encodeVarintOsm(dAtA, i, uint64(len(m.Strings[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Bounds != nil {
		{
			size, err := m.Bounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Open != nil {
		i--
		if *m.Open {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ClosedAt != nil {
		i = encodeVarintOsm(dAtA, i, uint64(*m.ClosedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.CreatedAt != nil {
		i = encodeVarintOsm(dAtA, i, uint64(*m.CreatedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.UserSid != nil {
		i = encodeVarintOsm(dAtA, i, uint64(*m.UserSid))
		i--
		dAtA[i] = 0x30
	}
	if m.UserId != nil {
		i = encodeVarintOsm(dAtA, i, uint64(*m.UserId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Vals) > 0 {
		dAtA4 := make([]byte, len(m.Vals)*10)
		var j3 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintOsm(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		dAtA6 := make([]byte, len(m.Keys)*10)
		var j5 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintOsm(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		i = encodeVarintOsm(dAtA, i, uint64(*m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Bounds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bounds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bounds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MaxLat)<<1)^uint64((m.MaxLat>>63))))
	i--
	dAtA[i] = 0x20
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MinLat)<<1)^uint64((m.MinLat>>63))))
	i--
	dAtA[i] = 0x18
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MaxLon)<<1)^uint64((m.MaxLon>>63))))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.MinLon)<<1)^uint64((m.MinLon>>63))))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Change) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Change) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Change) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strings[iNdEx])
			copy(dAtA[i:], m.Strings[iNdEx])
			i = encodeVarintOsm(dAtA, i, uint64(len(m.Strings[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Modify != nil {
		{
			size, err := m.Modify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Create != nil {
		{
			size, err := m.Create.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeysVals) > 0 {
		for iNdEx := len(m.KeysVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeysVals[iNdEx])
			copy(dAtA[i:], m.KeysVals[iNdEx])
			i = encodeVarintOsm(dAtA, i, uint64(len(m.KeysVals[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OSM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OSM) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OSM) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strings[iNdEx])
			copy(dAtA[i:], m.Strings[iNdEx])
			i = encodeVarintOsm(dAtA, i, uint64(len(m.Strings[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOsm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Ways) > 0 {
		for iNdEx := len(m.Ways) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ways[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOsm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DenseNodes != nil {
		{
			size, err := m.DenseNodes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOsm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Bounds != nil {
		{
			size, err := m.Bounds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.Lon)<<1)^uint64((m.Lon>>63))))
	i--
	dAtA[i] = 0x48
	i = encodeVarintOsm(dAtA, i, uint64((uint64(m.Lat)<<1)^uint64((m.Lat>>63))))
	i--
	dAtA[i] = 0x40
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vals) > 0 {
		dAtA15 := make([]byte, len(m.Vals)*10)
		var j14 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintOsm(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		dAtA17 := make([]byte, len(m.Keys)*10)
		var j16 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintOsm(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintOsm(dAtA, i, uint64(m.Id))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Committed != nil {
		i = encodeVarintOsm(dAtA, i, uint64(*m.Committed))
		i--
		dAtA[i] = 0x38
	}
	if m.Visible != nil {
		i--
		if *m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	i = encodeVarintOsm(dAtA, i, uint64(m.UserSid))
	i--
	dAtA[i] = 0x28
	i = encodeVarintOsm(dAtA, i, uint64(m.UserId))
	i--
	dAtA[i] = 0x20
	i = encodeVarintOsm(dAtA, i, uint64(m.ChangesetId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintOsm(dAtA, i, uint64(m.Timestamp))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOsm(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DenseNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseNodes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenseNodes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Strings) > 0 {
		for iNdEx := len(m.Strings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strings[iNdEx])
			copy(dAtA[i:], m.Strings[iNdEx])
			i = encodeVarintOsm(dAtA, i, uint64(len(m.Strings[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.KeysVals) > 0 {
		dAtA19 := make([]byte, len(m.KeysVals)*10)
		var j18 int
		for _, num := range m.KeysVals {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintOsm(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Lons) > 0 {
		var j20 int
		dAtA22 := make([]byte, len(m.Lons)*10)
		for _, num := range m.Lons {
			x21 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x21 >= 1<<7 {
				dAtA22[j20] = uint8(uint64(x21)&0x7f | 0x80)
				j20++
				x21 >>= 7
			}
			dAtA22[j20] = uint8(x21)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA22[:j20])
		i = encodeVarintOsm(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Lats) > 0 {
		var j23 int
		dAtA25 := make([]byte, len(m.Lats)*10)
		for _, num := range m.Lats {
			x24 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x24 >= 1<<7 {
				dAtA25[j23] = uint8(uint64(x24)&0x7f | 0x80)
				j23++
				x24 >>= 7
			}
			dAtA25[j23] = uint8(x24)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA25[:j23])
		i = encodeVarintOsm(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x42
	}
	if m.DenseInfo != nil {
		{
			size, err := m.DenseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ids) > 0 {
		var j27 int
		dAtA29 := make([]byte, len(m.Ids)*10)
		for _, num := range m.Ids {
			x28 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x28 >= 1<<7 {
				dAtA29[j27] = uint8(uint64(x28)&0x7f | 0x80)
				j27++
				x28 >>= 7
			}
			dAtA29[j27] = uint8(x28)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA29[:j27])
		i = encodeVarintOsm(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DenseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Committeds) > 0 {
		var j30 int
		dAtA32 := make([]byte, len(m.Committeds)*10)
		for _, num := range m.Committeds {
			x31 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x31 >= 1<<7 {
				dAtA32[j30] = uint8(uint64(x31)&0x7f | 0x80)
				j30++
				x31 >>= 7
			}
			dAtA32[j30] = uint8(x31)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA32[:j30])
		i = encodeVarintOsm(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Visibles) > 0 {
		for iNdEx := len(m.Visibles) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Visibles[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintOsm(dAtA, i, uint64(len(m.Visibles)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UserSids) > 0 {
		dAtA33 := make([]byte, len(m.UserSids)*5)
		var j34 int
		for _, num := range m.UserSids {
			x35 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x35 >= 1<<7 {
				dAtA33[j34] = uint8(uint64(x35)&0x7f | 0x80)
				j34++
				x35 >>= 7
			}
			dAtA33[j34] = uint8(x35)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA33[:j34])
		i = encodeVarintOsm(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UserIds) > 0 {
		dAtA36 := make([]byte, len(m.UserIds)*5)
		var j37 int
		for _, num := range m.UserIds {
			x38 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x38 >= 1<<7 {
				dAtA36[j37] = uint8(uint64(x38)&0x7f | 0x80)
				j37++
				x38 >>= 7
			}
			dAtA36[j37] = uint8(x38)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA36[:j37])
		i = encodeVarintOsm(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChangesetIds) > 0 {
		var j39 int
		dAtA41 := make([]byte, len(m.ChangesetIds)*10)
		for _, num := range m.ChangesetIds {
			x40 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x40 >= 1<<7 {
				dAtA41[j39] = uint8(uint64(x40)&0x7f | 0x80)
				j39++
				x40 >>= 7
			}
			dAtA41[j39] = uint8(x40)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA41[:j39])
		i = encodeVarintOsm(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Timestamps) > 0 {
		var j42 int
		dAtA44 := make([]byte, len(m.Timestamps)*10)
		for _, num := range m.Timestamps {
			x43 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x43 >= 1<<7 {
				dAtA44[j42] = uint8(uint64(x43)&0x7f | 0x80)
				j42++
				x43 >>= 7
			}
			dAtA44[j42] = uint8(x43)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA44[:j42])
		i = encodeVarintOsm(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Versions) > 0 {
		dAtA46 := make([]byte, len(m.Versions)*10)
		var j45 int
		for _, num1 := range m.Versions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			dAtA46[j45] = uint8(num)
			j45++
		}
		i -= j45
		copy(dAtA[i:], dAtA46[:j45])
		i = encodeVarintOsm(dAtA, i, uint64(j45))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Way) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Way) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Way) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Updates != nil {
		{
			size, err := m.Updates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.DenseMembers != nil {
		{
			size, err := m.DenseMembers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Refs) > 0 {
		var j49 int
		dAtA51 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x50 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x50 >= 1<<7 {
				dAtA51[j49] = uint8(uint64(x50)&0x7f | 0x80)
				j49++
				x50 >>= 7
			}
			dAtA51[j49] = uint8(x50)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA51[:j49])
		i = encodeVarintOsm(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0x42
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vals) > 0 {
		dAtA54 := make([]byte, len(m.Vals)*10)
		var j53 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintOsm(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		dAtA56 := make([]byte, len(m.Keys)*10)
		var j55 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintOsm(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintOsm(dAtA, i, uint64(m.Id))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Updates != nil {
		{
			size, err := m.Updates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DenseMembers != nil {
		{
			size, err := m.DenseMembers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Types) > 0 {
		dAtA60 := make([]byte, len(m.Types)*10)
		var j59 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintOsm(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Refs) > 0 {
		var j61 int
		dAtA63 := make([]byte, len(m.Refs)*10)
		for _, num := range m.Refs {
			x62 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x62 >= 1<<7 {
				dAtA63[j61] = uint8(uint64(x62)&0x7f | 0x80)
				j61++
				x62 >>= 7
			}
			dAtA63[j61] = uint8(x62)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA63[:j61])
		i = encodeVarintOsm(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Roles) > 0 {
		dAtA65 := make([]byte, len(m.Roles)*10)
		var j64 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintOsm(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x42
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOsm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vals) > 0 {
		dAtA68 := make([]byte, len(m.Vals)*10)
		var j67 int
		for _, num := range m.Vals {
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		i -= j67
		copy(dAtA[i:], dAtA68[:j67])
		i = encodeVarintOsm(dAtA, i, uint64(j67))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keys) > 0 {
		dAtA70 := make([]byte, len(m.Keys)*10)
		var j69 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintOsm(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintOsm(dAtA, i, uint64(m.Id))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DenseMembers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseMembers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DenseMembers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Lons) > 0 {
		var j71 int
		dAtA73 := make([]byte, len(m.Lons)*10)
		for _, num := range m.Lons {
			x72 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x72 >= 1<<7 {
				dAtA73[j71] = uint8(uint64(x72)&0x7f | 0x80)
				j71++
				x72 >>= 7
			}
			dAtA73[j71] = uint8(x72)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA73[:j71])
		i = encodeVarintOsm(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Lats) > 0 {
		var j74 int
		dAtA76 := make([]byte, len(m.Lats)*10)
		for _, num := range m.Lats {
			x75 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x75 >= 1<<7 {
				dAtA76[j74] = uint8(uint64(x75)&0x7f | 0x80)
				j74++
				x75 >>= 7
			}
			dAtA76[j74] = uint8(x75)
			j74++
		}
		i -= j74
		copy(dAtA[i:], dAtA76[:j74])
		i = encodeVarintOsm(dAtA, i, uint64(j74))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Orientation) > 0 {
		dAtA77 := make([]byte, len(m.Orientation)*5)
		var j78 int
		for _, num := range m.Orientation {
			x79 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x79 >= 1<<7 {
				dAtA77[j78] = uint8(uint64(x79)&0x7f | 0x80)
				j78++
				x79 >>= 7
			}
			dAtA77[j78] = uint8(x79)
			j78++
		}
		i -= j78
		copy(dAtA[i:], dAtA77[:j78])
		i = encodeVarintOsm(dAtA, i, uint64(j78))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ChangesetIds) > 0 {
		var j80 int
		dAtA82 := make([]byte, len(m.ChangesetIds)*10)
		for _, num := range m.ChangesetIds {
			x81 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x81 >= 1<<7 {
				dAtA82[j80] = uint8(uint64(x81)&0x7f | 0x80)
				j80++
				x81 >>= 7
			}
			dAtA82[j80] = uint8(x81)
			j80++
		}
		i -= j80
		copy(dAtA[i:], dAtA82[:j80])
		i = encodeVarintOsm(dAtA, i, uint64(j80))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Timestamps) > 0 {
		var j83 int
		dAtA85 := make([]byte, len(m.Timestamps)*10)
		for _, num := range m.Timestamps {
			x84 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x84 >= 1<<7 {
				dAtA85[j83] = uint8(uint64(x84)&0x7f | 0x80)
				j83++
				x84 >>= 7
			}
			dAtA85[j83] = uint8(x84)
			j83++
		}
		i -= j83
		copy(dAtA[i:], dAtA85[:j83])
		i = encodeVarintOsm(dAtA, i, uint64(j83))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Versions) > 0 {
		dAtA87 := make([]byte, len(m.Versions)*10)
		var j86 int
		for _, num1 := range m.Versions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA87[j86] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j86++
			}
			dAtA87[j86] = uint8(num)
			j86++
		}
		i -= j86
		copy(dAtA[i:], dAtA87[:j86])
		i = encodeVarintOsm(dAtA, i, uint64(j86))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Indexes) > 0 {
		dAtA88 := make([]byte, len(m.Indexes)*5)
		var j89 int
		for _, num := range m.Indexes {
			x90 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x90 >= 1<<7 {
				dAtA88[j89] = uint8(uint64(x90)&0x7f | 0x80)
				j89++
				x90 >>= 7
			}
			dAtA88[j89] = uint8(x90)
			j89++
		}
		i -= j89
		copy(dAtA[i:], dAtA88[:j89])
		i = encodeVarintOsm(dAtA, i, uint64(j89))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOsm(dAtA []byte, offset int, v uint64) int {
	offset -= sovOsm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Changeset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		n += 1 + sovOsm(uint64(*m.Id))
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.UserId != nil {
		n += 1 + sovOsm(uint64(*m.UserId))
	}
	if m.UserSid != nil {
		n += 1 + sovOsm(uint64(*m.UserSid))
	}
	if m.CreatedAt != nil {
		n += 1 + sovOsm(uint64(*m.CreatedAt))
	}
	if m.ClosedAt != nil {
		n += 1 + sovOsm(uint64(*m.ClosedAt))
	}
	if m.Open != nil {
		n += 2
	}
	if m.Bounds != nil {
		l = m.Bounds.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 2 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Bounds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sozOsm(uint64(m.MinLon))
	n += 1 + sozOsm(uint64(m.MaxLon))
	n += 1 + sozOsm(uint64(m.MinLat))
	n += 1 + sozOsm(uint64(m.MaxLat))
	return n
}

func (m *Change) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Modify != nil {
		l = m.Modify.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 2 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Tags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeysVals) > 0 {
		for _, s := range m.KeysVals {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *OSM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bounds != nil {
		l = m.Bounds.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if m.DenseNodes != nil {
		l = m.DenseNodes.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Ways) > 0 {
		for _, e := range m.Ways {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	n += 1 + sozOsm(uint64(m.Lat))
	n += 1 + sozOsm(uint64(m.Lon))
	return n
}

func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Version))
	n += 1 + sovOsm(uint64(m.Timestamp))
	n += 1 + sovOsm(uint64(m.ChangesetId))
	n += 1 + sovOsm(uint64(m.UserId))
	n += 1 + sovOsm(uint64(m.UserSid))
	if m.Visible != nil {
		n += 2
	}
	if m.Committed != nil {
		n += 1 + sovOsm(uint64(*m.Committed))
	}
	return n
}

func (m *DenseNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseInfo != nil {
		l = m.DenseInfo.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Lats) > 0 {
		l = 0
		for _, e := range m.Lats {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lons) > 0 {
		l = 0
		for _, e := range m.Lons {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.KeysVals) > 0 {
		l = 0
		for _, e := range m.KeysVals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Strings) > 0 {
		for _, s := range m.Strings {
			l = len(s)
			n += 1 + l + sovOsm(uint64(l))
		}
	}
	return n
}

func (m *DenseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Versions) > 0 {
		l = 0
		for _, e := range m.Versions {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Timestamps) > 0 {
		l = 0
		for _, e := range m.Timestamps {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.ChangesetIds) > 0 {
		l = 0
		for _, e := range m.ChangesetIds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.UserSids) > 0 {
		l = 0
		for _, e := range m.UserSids {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Visibles) > 0 {
		n += 1 + sovOsm(uint64(len(m.Visibles))) + len(m.Visibles)*1
	}
	if len(m.Committeds) > 0 {
		l = 0
		for _, e := range m.Committeds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	return n
}

func (m *Way) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseMembers != nil {
		l = m.DenseMembers.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Updates != nil {
		l = m.Updates.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	return n
}

func (m *Relation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOsm(uint64(m.Id))
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Vals) > 0 {
		l = 0
		for _, e := range m.Vals {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Refs) > 0 {
		l = 0
		for _, e := range m.Refs {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if m.DenseMembers != nil {
		l = m.DenseMembers.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	if m.Updates != nil {
		l = m.Updates.Size()
		n += 1 + l + sovOsm(uint64(l))
	}
	return n
}

func (m *DenseMembers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		l = 0
		for _, e := range m.Indexes {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Versions) > 0 {
		l = 0
		for _, e := range m.Versions {
			l += sovOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Timestamps) > 0 {
		l = 0
		for _, e := range m.Timestamps {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.ChangesetIds) > 0 {
		l = 0
		for _, e := range m.ChangesetIds {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Orientation) > 0 {
		l = 0
		for _, e := range m.Orientation {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lats) > 0 {
		l = 0
		for _, e := range m.Lats {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	if len(m.Lons) > 0 {
		l = 0
		for _, e := range m.Lons {
			l += sozOsm(uint64(e))
		}
		n += 1 + sovOsm(uint64(l)) + l
	}
	return n
}

func sovOsm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOsm(x uint64) (n int) {
	return sovOsm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Changeset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Changeset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Changeset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Id = &v
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Keys) == 0 {
					m.Keys = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Vals) == 0 {
					m.Vals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserId = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserSid = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreatedAt = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedAt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClosedAt = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Open = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bounds == nil {
				m.Bounds = &Bounds{}
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &Change{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bounds) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bounds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bounds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MinLon = int64(v)
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MaxLon = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MinLat = int64(v)
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.MaxLat = int64(v)
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("min_lon")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("max_lon")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("min_lat")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("max_lat")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Change) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &OSM{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modify == nil {
				m.Modify = &OSM{}
			}
			if err := m.Modify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &OSM{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &OSM{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeysVals = append(m.KeysVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bounds == nil {
				m.Bounds = &Bounds{}
			}
			if err := m.Bounds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseNodes == nil {
				m.DenseNodes = &DenseNodes{}
			}
			if err := m.DenseNodes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ways = append(m.Ways, &Way{})
			if err := m.Ways[len(m.Ways)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Keys) == 0 {
					m.Keys = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Vals) == 0 {
					m.Vals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lat = int64(v)
			hasFields[0] |= uint64(0x00000002)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Lon = int64(v)
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lat")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("lon")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetId", wireType)
			}
			m.ChangesetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangesetId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSid", wireType)
			}
			m.UserSid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserSid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Visible = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Committed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Ids = append(m.Ids, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Ids = append(m.Ids, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseInfo == nil {
				m.DenseInfo = &DenseInfo{}
			}
			if err := m.DenseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lats = append(m.Lats, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lats) == 0 {
					m.Lats = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lats = append(m.Lats, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lats", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lons = append(m.Lons, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lons) == 0 {
					m.Lons = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lons = append(m.Lons, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lons", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeysVals = append(m.KeysVals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeysVals) == 0 {
					m.KeysVals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeysVals = append(m.KeysVals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysVals", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strings = append(m.Strings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Versions = append(m.Versions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Versions) == 0 {
					m.Versions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Versions = append(m.Versions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Timestamps = append(m.Timestamps, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Timestamps) == 0 {
					m.Timestamps = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Timestamps = append(m.Timestamps, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamps", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ChangesetIds = append(m.ChangesetIds, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChangesetIds) == 0 {
					m.ChangesetIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ChangesetIds = append(m.ChangesetIds, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetIds", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIds) == 0 {
					m.UserIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.UserSids = append(m.UserSids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserSids) == 0 {
					m.UserSids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.UserSids = append(m.UserSids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSids", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Visibles = append(m.Visibles, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Visibles) == 0 {
					m.Visibles = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Visibles = append(m.Visibles, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibles", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Committeds = append(m.Committeds, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Committeds) == 0 {
					m.Committeds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Committeds = append(m.Committeds, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Committeds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Way) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Way: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Way: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Keys) == 0 {
					m.Keys = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Vals) == 0 {
					m.Vals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Refs) == 0 {
					m.Refs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseMembers == nil {
				m.DenseMembers = &DenseMembers{}
			}
			if err := m.DenseMembers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Updates == nil {
				m.Updates = &DenseMembers{}
			}
			if err := m.Updates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Keys) == 0 {
					m.Keys = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Vals = append(m.Vals, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Vals) == 0 {
					m.Vals = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Vals = append(m.Vals, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vals", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Roles) == 0 {
					m.Roles = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Refs = append(m.Refs, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Refs) == 0 {
					m.Refs = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Refs = append(m.Refs, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
		case 10:
			if wireType == 0 {
				var v Relation_MemberType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Relation_MemberType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]Relation_MemberType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Relation_MemberType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Relation_MemberType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DenseMembers == nil {
				m.DenseMembers = &DenseMembers{}
			}
			if err := m.DenseMembers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOsm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOsm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Updates == nil {
				m.Updates = &DenseMembers{}
			}
			if err := m.Updates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseMembers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseMembers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseMembers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Indexes = append(m.Indexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indexes) == 0 {
					m.Indexes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Indexes = append(m.Indexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Versions = append(m.Versions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Versions) == 0 {
					m.Versions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Versions = append(m.Versions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Timestamps = append(m.Timestamps, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Timestamps) == 0 {
					m.Timestamps = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Timestamps = append(m.Timestamps, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamps", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.ChangesetIds = append(m.ChangesetIds, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChangesetIds) == 0 {
					m.ChangesetIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.ChangesetIds = append(m.ChangesetIds, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetIds", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Orientation = append(m.Orientation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Orientation) == 0 {
					m.Orientation = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Orientation = append(m.Orientation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Orientation", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lats = append(m.Lats, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lats) == 0 {
					m.Lats = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lats = append(m.Lats, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lats", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Lons = append(m.Lons, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOsm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOsm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOsm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lons) == 0 {
					m.Lons = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOsm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Lons = append(m.Lons, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lons", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOsm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOsm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOsm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOsm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOsm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOsm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOsm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOsm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOsm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOsm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOsm = fmt.Errorf("proto: unexpected end of group")
)
